import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root'
})
export class WebAuthnService {

  constructor() { }

  //* Generates a random buffer to use as a challenge, which is a unique value needed for security
  //* Генерирует случайный буфер для использования в качестве вызова, который представляет собой уникальное значение, необходимое для безопасности.
  private generateRandomBuffer(length: number): Uint8Array {
    const randomBuffer = new Uint8Array(length);
    window.crypto.getRandomValues(randomBuffer); // Fills the buffer with cryptographically secure random values || Заполняет буфер криптографически безопасными случайными значениями.
    return randomBuffer;
  }

  //* Registers a new credential (like a fingerprint or Face ID) for the user
  //* Регистрирует новые учетные данные (например, отпечаток пальца или Face ID) для пользователя.
  async register() {
    //* Generate a unique challenge for the registration process
    //* Создайте уникальную задачу для процесса регистрации
    const challenge = this.generateRandomBuffer(32);

    //* PublicKeyCredentialCreationOptions is the core object needed for registration
    //* PublicKeyCredentialCreationOptions является основным объектом, необходимым для регистрации
    const publicKey: PublicKeyCredentialCreationOptions = {
      challenge: challenge, // A random value generated by the server to ensure the request is fresh and unique || Случайное значение, генерируемое сервером для обеспечения новизны и уникальности запроса.
      rp: { // Relying Party (your app) information || Информация о проверяющей стороне (ваше приложение)
        name: "OurAwesomeApp" // Display name of your app || Отображаемое имя вашего приложения
      },
      user: { // User information || Информация о пользователе
        id: this.generateRandomBuffer(16), // A unique identifier for the user || Уникальный идентификатор пользователя
        name: "user@example.com", // User's email or username || Адрес электронной почты или имя пользователя
        displayName: "User Example" // A friendly name for the user || Дружественное имя для пользователя
      },
      pubKeyCredParams: [{ // Array of acceptable public key algorithms || Массив приемлемых алгоритмов открытого ключа
        type: "public-key",
        alg: -7  // Represents the ES256 algorithm (Elliptic Curve Digital Signature Algorithm) || Представляет алгоритм ES256
      }],
      authenticatorSelection: { // Criteria for selecting the appropriate authenticator || Критерии выбора подходящего аутентификатора
        authenticatorAttachment: "platform", // Ensures we use the device's built-in biometric authenticator like Touch ID or Face ID || Обеспечивает использование встроенного в устройство биометрического аутентификатора, например Touch ID или Face ID.
        userVerification: "required" // Requires user verification (e.g., fingerprint or face scan) || Требуется проверка пользователя (например, сканирование отпечатков пальцев или лица)
      },
      timeout: 60000, // Timeout for the registration operation in milliseconds || Время ожидания операции регистрации в миллисекундах
      attestation: "direct" // Attestation provides proof of the authenticator's properties and is sent back to the server || Аттестация подтверждает свойства аутентификатора и отправляется обратно на сервер.
    };

    try {
      //* This will prompt the user to register their biometric credential
      //* Это предложит пользователю зарегистрировать свои биометрические данные.
      const credential = await navigator.credentials.create({ publicKey }) as PublicKeyCredential;
      this.storeCredential(credential, challenge); // Store the credential details locally for demo purposes || Сохраните данные учетной записи локально для демонстрационных целей.
      console.log("Registration successful! || Регистрация прошла успешно!", credential);
      return credential; // Return the credential object containing the user's public key and other details || Возвращает объект учетных данных, содержащий открытый ключ пользователя и другие данные.
    } catch (err) {
      console.error("Registration failed: || Регистрация не удалась:", err);
      throw err;
    }
  }

  //* Authenticates the user with stored credentials (like a fingerprint or Face ID)
  //* Аутентифицирует пользователя с помощью сохраненных учетных данных (например, отпечатка пальца или Face ID)
  async authenticate() {
    const storedCredential = this.getStoredCredential(); // Retrieve stored credential information || Извлечь сохраненную информацию об учетных данных
    if (!storedCredential) {
      throw new Error("No stored credential found. Please register first. || Сохраненные учетные данные не найдены. Пожалуйста, зарегистрируйтесь сначала.");
    }

    //* PublicKeyCredentialRequestOptions is used to prompt the user to authenticate
    //* PublicKeyCredentialRequestOptions используется для запроса аутентификации пользователя.
    const publicKey: PublicKeyCredentialRequestOptions = {
      challenge: new Uint8Array(storedCredential.challenge), // A new challenge to ensure the request is fresh and unique || Новая задача — обеспечить новизну и уникальность запроса.
      allowCredentials: [{ // Specifies which credentials can be used for authentication || Указывает, какие учетные данные могут использоваться для аутентификации.
        id: new Uint8Array(storedCredential.rawId), // The ID of the credential to use || Идентификатор учетных данных для использования
        type: "public-key"
      }],
      userVerification: "required", // Requires user verification (e.g., fingerprint or face scan) || Требуется проверка пользователя (например, сканирование отпечатков пальцев или лица)
      timeout: 60000 // Timeout for the authentication operation in milliseconds || Время ожидания для операции аутентификации в миллисекундах
    };

    try {
      //* This will prompt the user to authenticate using their registered biometric credential
      //* Это предложит пользователю пройти аутентификацию, используя зарегистрированные биометрические данные.
      const credential = await navigator.credentials.get({ publicKey }) as PublicKeyCredential;
      console.log("Authentication successful! || Аутентификация прошла успешно!", credential);
      return credential; // Return the credential object with authentication details || Верните объект учетных данных с данными аутентификации.
    } catch (err) {
      console.error("Authentication failed: || Аутентификация не удалась:", err);
      throw err;
    }
  }

  //* Stores credential data in localStorage (for demo purposes only; this should be handled securely in production)
  //* Сохраняет учетные данные в localStorage (только для демонстрационных целей; в рабочей среде это должно обрабатываться безопасно)
  private storeCredential(credential: PublicKeyCredential, challenge: Uint8Array) {
    const credentialData = {
      rawId: Array.from(new Uint8Array(credential.rawId)), // Converts the raw ID to an array for storage || Преобразует необработанный идентификатор в массив для хранения.
      challenge: Array.from(challenge) // Converts the challenge to an array for storage || Преобразует задачу в массив для хранения.
    };
    localStorage.setItem('webauthn_credential', JSON.stringify(credentialData));
  }

  //* Retrieves stored credential data from localStorage
  //* Извлекает сохраненные учетные данные из localStorage
  private getStoredCredential(): any {
    const storedCredential = localStorage.getItem('webauthn_credential');
    return storedCredential ? JSON.parse(storedCredential) : null;
  }
}